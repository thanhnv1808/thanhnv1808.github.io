---
title: "LeetCode 1: Two Sum - Hash Map Optimization"
author: thanhnv1808
date: 2025-11-24 18:00:00 +0700
categories: [Algorithms, LeetCode]
tags: [leetcode, algorithms, array, hash-map, two-pointers]
description: Learn how to solve the classic Two Sum problem efficiently using hash maps, reducing time complexity from O(nÂ²) to O(n).
comments: true
---

## Problem Statement

Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

**Link**: [LeetCode 1 - Two Sum](https://leetcode.com/problems/two-sum/description/)

### Examples

**Example 1:**
```plaintext
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```
{: .nolineno }

**Example 2:**
```plaintext
Input: nums = [3,2,4], target = 6
Output: [1,2]
```
{: .nolineno }

**Example 3:**
```plaintext
Input: nums = [3,3], target = 6
Output: [0,1]
```
{: .nolineno }

### Constraints

- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- Only one valid answer exists.

### Follow-up

Can you come up with an algorithm that is less than O(nÂ²) time complexity?

---

## Solution 1: Brute Force (Nested Loops)

The most straightforward approach is to check every possible pair of numbers in the array.

### Approach

1. Use two nested loops to iterate through all pairs of elements
2. For each pair `(i, j)` where `i < j`, check if `nums[i] + nums[j] == target`
3. If a match is found, return the indices `[i, j]`
4. Since the problem guarantees exactly one solution, we'll always find it

### Complexity Analysis

- **Time Complexity**: O(nÂ²) - We have nested loops, checking n(n-1)/2 pairs in the worst case
- **Space Complexity**: O(1) - We only use a constant amount of extra space

### TypeScript Implementation

```typescript
function twoSum(nums: number[], target: number): number[] {
    if (nums.length == 2) return [0, 1];

    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] == target) {
                return [i, j];
            }
        }
    }
    
    return [];
}
```

### Why This Works

- **Exhaustive search** - We check every possible pair of elements
- **Simple logic** - Easy to understand and implement
- **No extra space** - We don't need any additional data structures

### Example Trace

For `nums = [2,7,11,15]`, `target = 9`:

```
i=0, j=1: nums[0] + nums[1] = 2 + 7 = 9 âœ“ (match found!)
Return: [0, 1]
```

For `nums = [3,2,4]`, `target = 6`:

```
i=0, j=1: nums[0] + nums[1] = 3 + 2 = 5 â‰  6
i=0, j=2: nums[0] + nums[2] = 3 + 4 = 7 â‰  6
i=1, j=2: nums[1] + nums[2] = 2 + 4 = 6 âœ“ (match found!)
Return: [1, 2]
```

---

## Solution 2: Hash Map (Optimal)

This approach uses a hash map to store previously seen numbers and their indices, allowing us to find the complement in O(1) time.

### Approach

1. Create a hash map to store `number â†’ index` mappings
2. Iterate through the array once
3. For each element `nums[i]`:
   - Calculate the complement: `complement = target - nums[i]`
   - Check if the complement exists in the map
   - If found, return `[i, map.get(complement)]`
   - Otherwise, add `nums[i]` to the map with its index
4. Since the problem guarantees a solution, we'll always find it before the loop ends

### Complexity Analysis

- **Time Complexity**: O(n) - We iterate through the array once, and hash map operations (insertion and lookup) are O(1) on average
- **Space Complexity**: O(n) - In the worst case, we store n-1 elements in the hash map before finding the solution

### TypeScript Implementation

```typescript
function twoSum(nums: number[], target: number): number[] {
    const mapNum = new Map<number, number>();

    for (let i = 0; i < nums.length; i++) {
        const cur = nums[i];
        const complement = target - cur;
        
        if (mapNum.has(complement)) {
            return [i, mapNum.get(complement)!];
        }
        
        mapNum.set(cur, i);
    }
    
    return [];
}
```

### Why This Works

- **One-pass solution** - We only need to iterate through the array once
- **Hash map provides O(1) lookup** - Checking if a complement exists is very fast
- **Store as we go** - We add elements to the map as we encounter them, so when we find the complement, we already have its index stored

### Example Trace

For `nums = [2,7,11,15]`, `target = 9`:

```
Step 1: i=0, cur=2
  complement = 9 - 2 = 7
  mapNum.has(7)? No (map is empty)
  mapNum.set(2, 0)
  mapNum = {2: 0}

Step 2: i=1, cur=7
  complement = 9 - 7 = 2
  mapNum.has(2)? Yes âœ“ (found complement!)
  mapNum.get(2) = 0
  Return: [1, 0]
```

For `nums = [3,2,4]`, `target = 6`:

```
Step 1: i=0, cur=3
  complement = 6 - 3 = 3
  mapNum.has(3)? No
  mapNum.set(3, 0)
  mapNum = {3: 0}

Step 2: i=1, cur=2
  complement = 6 - 2 = 4
  mapNum.has(4)? No
  mapNum.set(2, 1)
  mapNum = {3: 0, 2: 1}

Step 3: i=2, cur=4
  complement = 6 - 4 = 2
  mapNum.has(2)? Yes âœ“ (found complement!)
  mapNum.get(2) = 1
  Return: [2, 1]
```

### Important Note

Notice that we check for the complement **before** adding the current element to the map. This ensures we don't accidentally use the same element twice. For example, if `nums = [3, 3]` and `target = 6`:

```
Step 1: i=0, cur=3
  complement = 6 - 3 = 3
  mapNum.has(3)? No (map is empty)
  mapNum.set(3, 0)
  mapNum = {3: 0}

Step 2: i=1, cur=3
  complement = 6 - 3 = 3
  mapNum.has(3)? Yes âœ“ (found complement!)
  mapNum.get(3) = 0
  Return: [1, 0]
```

If we had added the element before checking, we might incorrectly use the same index twice.

---

## Comparison of Solutions

| Solution | Time Complexity | Space Complexity | Best For |
|----------|----------------|------------------|----------|
| Brute Force | O(nÂ²) | O(1) | Small arrays, educational purposes |
| Hash Map | O(n) | O(n) | General use, optimal performance |

> ðŸ’¡ **Recommendation**: Use the **Hash Map approach** for optimal performance. It reduces time complexity from O(nÂ²) to O(n) with a reasonable space trade-off. The brute force approach is only suitable for very small arrays or when learning the problem.
{: .prompt-tip }

---

## Key Takeaways

1. **Hash maps enable O(1) lookups** - This is the key to optimizing from O(nÂ²) to O(n) time complexity
2. **One-pass solution** - We can solve the problem in a single iteration by storing information as we go
3. **Check before adding** - Always check for the complement before adding the current element to avoid using the same element twice
4. **Space-time trade-off** - The hash map solution uses O(n) extra space to achieve O(n) time, which is a worthwhile trade-off
5. **Classic pattern** - This "complement lookup" pattern appears in many array problems

---

## Related Problems

- [LeetCode 15: 3Sum](https://leetcode.com/problems/3sum/) - Find three numbers that add up to zero
- [LeetCode 18: 4Sum](https://leetcode.com/problems/4sum/) - Find four numbers that add up to target
- [LeetCode 167: Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) - Two sum with sorted array (can use two pointers)
- [LeetCode 170: Two Sum III - Data structure design](https://leetcode.com/problems/two-sum-iii-data-structure-design/) - Design a data structure for two sum operations

---

## Practice

Try solving this problem on LeetCode: [1. Two Sum](https://leetcode.com/problems/two-sum/)

